import shutil
from pathlib import Path
from typing import List, Optional

import astropy.units as u
import numpy as np
from astropy.io import fits
from matadrs.utils.plot import Plotter


def compute_stellar_radius(luminosity: u.Lsun, temperature: u.K) -> u.Rsun:
    """Calculates the stellar radius from the luminosity and temperature."""
    luminosity, temperature = (
        u.Quantity(luminosity, u.Lsun),
        u.Quantity(temperature, u.K),
    )
    return np.sqrt(
        luminosity.to(u.W) / (4 * np.pi * const.sigma_sb * temperature**4)
    ).to(u.Rsun)


def angular_to_distance(angular_diameter: u.mas, distance: u.pc) -> u.m:
    """Converts an angular diameter of an object at a certain distance
    from the observer from mas to meters.

    Parameters
    ----------
    angular_diameter : astropy.units.mas
        The angular diameter of an object.
    distance : astropy.units.pc
        The distance to the object.

    Returns
    -------
    diameter : astropy.units.m
        The diameter of the object.

    Notes
    -----
    The formula for the angular diameter small angle approximation is

    .. math:: d = \\delta*D

    where 'd' is the diameter of the object and 'D' is the distance from the
    observer to the object and ..math::`\\delta` is the angular diameter.
    """
    return angular_diameter.to(u.rad).value * distance.to(u.m)


def distance_to_angular(diameter: u.au, distance: u.pc) -> u.mas:
    """Converts an angular diameter of an object at a certain distance
    from the observer from mas to meters.

    Parameters
    ----------
    diameter : astropy.units.au
        The diameter of an object.
    distance : astropy.units.pc
        The distance to the object.

    Returns
    -------
    diameter : astropy.units.mas
        The diameter of the object.

    Notes
    -----
    The formula for the angular diameter small angle approximation is

    .. math:: \\delta = \\frac{d}{D}

    where 'd' is the diameter of the object and 'D' is the distance from the
    observer to the object and ..math::`\\delta` is the angular diameter.
    """
    return ((diameter.to(u.m) / distance.to(u.m)) * u.rad).to(u.mas)


def load_flux_model(flux_file: Path) -> np.ndarray:
    """Loads the flux models generated by RvB's code."""
    return np.loadtxt(flux_file, comments="#", unpack=True)[:2]


def average_total_flux(directory: Optional[Path] = None, **kwargs) -> None:
    """Averages toegether the fluxes for the 'mat_tools' reduction."""
    directory = Path.cwd() if directory is None else Path(directory)
    plot_dir = directory / "flux" / "plots"
    if not plot_dir.exists():
        plot_dir.mkdir(parents=True)
    for fits_file in list(directory.glob("*.fits")):
        with fits.open(fits_file, "readonly") as hdul:
            if "OI_FLUX" not in hdul:
                continue

        new_file = plot_dir.parent / f"{fits_file.stem}_flux_avg.fits"
        shutil.copy(fits_file, new_file)
        with fits.open(new_file, "update") as hdul:
            oi_flux = hdul["oi_flux"].data
            flux, fluxerr = oi_flux["fluxdata"], oi_flux["fluxerr"]
            avg_flux = np.mean(flux, axis=0)
            avg_fluxerr = np.sqrt(
                np.hypot(np.nanstd(flux, axis=0), np.nanmean(fluxerr, axis=0))
            )
            hdul["oi_flux"].data = hdul["oi_flux"].data[:1]
            hdul["oi_flux"].data["fluxdata"] = avg_flux
            hdul["oi_flux"].data["fluxerr"] = avg_fluxerr
            hdul.flush()
        plot = Plotter(new_file, save_dir=plot_dir)
        unwrap = True if "AQUARIUS" in fits_file.name else False
        plot.add_mosaic(unwrap=unwrap).plot(**kwargs)


def remove_flawed_telescope(fits_file: Path, telescopes: List[str], **kwargs) -> None:
    """Removes the data from one or more telescopes via their names.

    Parameters
    ----------
    fits_file : pathlib.Path
        The file to remove the data from.
    telescopes : list of str
        The names of the telescopes to remove the data from.
    """
    new_file = (
        fits_file.parent / f"{fits_file.stem}_{'-'.join(telescopes)}_removed.fits"
    )
    shutil.copy(fits_file, new_file)
    with fits.open(new_file, "update") as hdul:
        sta_indices = dict(
            zip(hdul["oi_array"].data["tel_name"], hdul["oi_array"].data["sta_index"])
        )
        for telescope in telescopes:
            sta_index = sta_indices[telescope]
            for entry in hdul:
                if entry.data is None:
                    continue
                if "STA_INDEX" not in entry.columns.names:
                    continue
                data = entry.data["sta_index"]
                if len(data.shape) == 1:
                    mask = data != sta_index
                    entry.data = entry.data[mask]
                else:
                    mask = np.any(data == sta_index, axis=1)
                    entry.data = entry.data[~mask]
        hdul.flush()
    plot = Plotter(new_file, save_dir=fits_file.parent)
    unwrap = True if "AQUARIUS" in new_file.name else False
    plot.add_mosaic(unwrap=unwrap).plot(**kwargs)


def replace_data(
    file: Path, file_for_replace: Path, header: str, sub_headers: List[str]
) -> None:
    """Replaces some data of a specific header and sub headers
    of file with the same of a different file.

    Useful when one part of data is corrupted, but all needs to be fitted.
    """
    with fits.open(file_for_replace) as hdul:
        data_to_inject = hdul[header].data

    with fits.open(file, "update") as hdul:
        data = hdul[header].data
        header = hdul[header].header
        if "INJECT" in header:
            print(
                "[SKIPPING]: There is already data"
                f"injected from another file for the '{header}' header."
            )
            return
        for sub_header in sub_headers:
            data[sub_header] = data_to_inject[sub_header]
        header["INJECT"] = f"Data injected from {file_for_replace.name}"
        hdul.flush()
